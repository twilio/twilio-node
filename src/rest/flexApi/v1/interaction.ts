/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Flex
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { inspect, InspectOptions } from "util";
import V1 from "../V1";
const deserialize = require("../../../base/deserialize");
const serialize = require("../../../base/serialize");
import { isValidPathParam } from "../../../base/utility";
import { InteractionChannelListInstance } from "./interaction/interactionChannel";

/**
 * Options to pass to update a InteractionInstance
 */
export interface InteractionContextUpdateOptions {
  /** The unique identifier for Interaction level webhook */
  webhookTtid?: string;
}

/**
 * Options to pass to create a InteractionInstance
 */
export interface InteractionListInstanceCreateOptions {
  /** The Interaction\\\'s channel. */
  channel: object;
  /** The Interaction\\\'s routing logic. */
  routing?: object;
  /** The Interaction context sid is used for adding a context lookup sid */
  interactionContextSid?: string;
  /** The unique identifier for Interaction level webhook */
  webhookTtid?: string;
}

export interface InteractionContext {
  channels: InteractionChannelListInstance;

  /**
   * Fetch a InteractionInstance
   *
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed InteractionInstance
   */
  fetch(
    callback?: (error: Error | null, item?: InteractionInstance) => any
  ): Promise<InteractionInstance>;

  /**
   * Update a InteractionInstance
   *
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed InteractionInstance
   */
  update(
    callback?: (error: Error | null, item?: InteractionInstance) => any
  ): Promise<InteractionInstance>;
  /**
   * Update a InteractionInstance
   *
   * @param params - Parameter for request
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed InteractionInstance
   */
  update(
    params: InteractionContextUpdateOptions,
    callback?: (error: Error | null, item?: InteractionInstance) => any
  ): Promise<InteractionInstance>;

  /**
   * Provide a user-friendly representation
   */
  toJSON(): any;
  [inspect.custom](_depth: any, options: InspectOptions): any;
}

export interface InteractionContextSolution {
  sid: string;
}

export class InteractionContextImpl implements InteractionContext {
  protected _solution: InteractionContextSolution;
  protected _uri: string;

  protected _channels?: InteractionChannelListInstance;

  constructor(protected _version: V1, sid: string) {
    if (!isValidPathParam(sid)) {
      throw new Error("Parameter 'sid' is not valid.");
    }

    this._solution = { sid };
    this._uri = `/Interactions/${sid}`;
  }

  get channels(): InteractionChannelListInstance {
    this._channels =
      this._channels ||
      InteractionChannelListInstance(this._version, this._solution.sid);
    return this._channels;
  }

  fetch(
    callback?: (error: Error | null, item?: InteractionInstance) => any
  ): Promise<InteractionInstance> {
    const headers: any = {};
    headers["Accept"] = "application/json";

    const instance = this;
    let operationVersion = instance._version,
      operationPromise = operationVersion.fetch({
        uri: instance._uri,
        method: "get",
        headers,
      });

    operationPromise = operationPromise.then(
      (payload) =>
        new InteractionInstance(
          operationVersion,
          payload,
          instance._solution.sid
        )
    );

    operationPromise = instance._version.setPromiseCallback(
      operationPromise,
      callback
    );
    return operationPromise;
  }

  update(
    params?:
      | InteractionContextUpdateOptions
      | ((error: Error | null, item?: InteractionInstance) => any),
    callback?: (error: Error | null, item?: InteractionInstance) => any
  ): Promise<InteractionInstance> {
    if (params instanceof Function) {
      callback = params;
      params = {};
    } else {
      params = params || {};
    }

    let data: any = {};

    if (params["webhookTtid"] !== undefined)
      data["WebhookTtid"] = params["webhookTtid"];

    const headers: any = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    headers["Accept"] = "application/json";

    const instance = this;
    let operationVersion = instance._version,
      operationPromise = operationVersion.update({
        uri: instance._uri,
        method: "post",
        data,
        headers,
      });

    operationPromise = operationPromise.then(
      (payload) =>
        new InteractionInstance(
          operationVersion,
          payload,
          instance._solution.sid
        )
    );

    operationPromise = instance._version.setPromiseCallback(
      operationPromise,
      callback
    );
    return operationPromise;
  }

  /**
   * Provide a user-friendly representation
   *
   * @returns Object
   */
  toJSON() {
    return this._solution;
  }

  [inspect.custom](_depth: any, options: InspectOptions) {
    return inspect(this.toJSON(), options);
  }
}

interface InteractionPayload extends InteractionResource {}

interface InteractionResource {
  sid: string;
  channel: Record<string, object>;
  routing: Record<string, object>;
  url: string;
  links: Record<string, string>;
  interaction_context_sid: string;
  webhook_ttid: string;
}

export class InteractionInstance {
  protected _solution: InteractionContextSolution;
  protected _context?: InteractionContext;

  constructor(
    protected _version: V1,
    payload: InteractionResource,
    sid?: string
  ) {
    this.sid = payload.sid;
    this.channel = payload.channel;
    this.routing = payload.routing;
    this.url = payload.url;
    this.links = payload.links;
    this.interactionContextSid = payload.interaction_context_sid;
    this.webhookTtid = payload.webhook_ttid;

    this._solution = { sid: sid || this.sid };
  }

  /**
   * The unique string created by Twilio to identify an Interaction resource, prefixed with KD.
   */
  sid: string;
  /**
   * A JSON object that defines the Interaction’s communication channel and includes details about the channel. See the [Outbound SMS](https://www.twilio.com/docs/flex/developer/conversations/interactions-api/interactions#agent-initiated-outbound-interactions) and [inbound (API-initiated)](https://www.twilio.com/docs/flex/developer/conversations/interactions-api/interactions#api-initiated-contact) Channel object examples.
   */
  channel: Record<string, object>;
  /**
   * A JSON Object representing the routing rules for the Interaction Channel. See [Outbound SMS Example](https://www.twilio.com/docs/flex/developer/conversations/interactions-api/interactions#agent-initiated-outbound-interactions) for an example Routing object. The Interactions resource uses TaskRouter for all routing functionality.   All attributes in the Routing object on your Interaction request body are added “as is” to the task. For a list of known attributes consumed by the Flex UI and/or Flex Insights, see [Known Task Attributes](https://www.twilio.com/docs/flex/developer/conversations/interactions-api#task-attributes).
   */
  routing: Record<string, object>;
  url: string;
  links: Record<string, string>;
  interactionContextSid: string;
  webhookTtid: string;

  private get _proxy(): InteractionContext {
    this._context =
      this._context ||
      new InteractionContextImpl(this._version, this._solution.sid);
    return this._context;
  }

  /**
   * Fetch a InteractionInstance
   *
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed InteractionInstance
   */
  fetch(
    callback?: (error: Error | null, item?: InteractionInstance) => any
  ): Promise<InteractionInstance> {
    return this._proxy.fetch(callback);
  }

  /**
   * Update a InteractionInstance
   *
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed InteractionInstance
   */
  update(
    callback?: (error: Error | null, item?: InteractionInstance) => any
  ): Promise<InteractionInstance>;
  /**
   * Update a InteractionInstance
   *
   * @param params - Parameter for request
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed InteractionInstance
   */
  update(
    params: InteractionContextUpdateOptions,
    callback?: (error: Error | null, item?: InteractionInstance) => any
  ): Promise<InteractionInstance>;

  update(
    params?: any,
    callback?: (error: Error | null, item?: InteractionInstance) => any
  ): Promise<InteractionInstance> {
    return this._proxy.update(params, callback);
  }

  /**
   * Access the channels.
   */
  channels(): InteractionChannelListInstance {
    return this._proxy.channels;
  }

  /**
   * Provide a user-friendly representation
   *
   * @returns Object
   */
  toJSON() {
    return {
      sid: this.sid,
      channel: this.channel,
      routing: this.routing,
      url: this.url,
      links: this.links,
      interactionContextSid: this.interactionContextSid,
      webhookTtid: this.webhookTtid,
    };
  }

  [inspect.custom](_depth: any, options: InspectOptions) {
    return inspect(this.toJSON(), options);
  }
}

export interface InteractionSolution {}

export interface InteractionListInstance {
  _version: V1;
  _solution: InteractionSolution;
  _uri: string;

  (sid: string): InteractionContext;
  get(sid: string): InteractionContext;

  /**
   * Create a InteractionInstance
   *
   * @param params - Parameter for request
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed InteractionInstance
   */
  create(
    params: InteractionListInstanceCreateOptions,
    callback?: (error: Error | null, item?: InteractionInstance) => any
  ): Promise<InteractionInstance>;

  /**
   * Provide a user-friendly representation
   */
  toJSON(): any;
  [inspect.custom](_depth: any, options: InspectOptions): any;
}

export function InteractionListInstance(version: V1): InteractionListInstance {
  const instance = ((sid) => instance.get(sid)) as InteractionListInstance;

  instance.get = function get(sid): InteractionContext {
    return new InteractionContextImpl(version, sid);
  };

  instance._version = version;
  instance._solution = {};
  instance._uri = `/Interactions`;

  instance.create = function create(
    params: InteractionListInstanceCreateOptions,
    callback?: (error: Error | null, items: InteractionInstance) => any
  ): Promise<InteractionInstance> {
    if (params === null || params === undefined) {
      throw new Error('Required parameter "params" missing.');
    }

    if (params["channel"] === null || params["channel"] === undefined) {
      throw new Error("Required parameter \"params['channel']\" missing.");
    }

    let data: any = {};

    data["Channel"] = serialize.object(params["channel"]);
    if (params["routing"] !== undefined)
      data["Routing"] = serialize.object(params["routing"]);
    if (params["interactionContextSid"] !== undefined)
      data["InteractionContextSid"] = params["interactionContextSid"];
    if (params["webhookTtid"] !== undefined)
      data["WebhookTtid"] = params["webhookTtid"];

    const headers: any = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    headers["Accept"] = "application/json";

    let operationVersion = version,
      operationPromise = operationVersion.create({
        uri: instance._uri,
        method: "post",
        data,
        headers,
      });

    operationPromise = operationPromise.then(
      (payload) => new InteractionInstance(operationVersion, payload)
    );

    operationPromise = instance._version.setPromiseCallback(
      operationPromise,
      callback
    );
    return operationPromise;
  };

  instance.toJSON = function toJSON() {
    return instance._solution;
  };

  instance[inspect.custom] = function inspectImpl(
    _depth: any,
    options: InspectOptions
  ) {
    return inspect(instance.toJSON(), options);
  };

  return instance;
}
