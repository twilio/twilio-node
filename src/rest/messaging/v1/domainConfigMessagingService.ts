/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Messaging
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { inspect, InspectOptions } from "util";
import V1 from "../V1";
const deserialize = require("../../../base/deserialize");
const serialize = require("../../../base/serialize");
import { isValidPathParam } from "../../../base/utility";
import { ApiResponse } from "../../../base/ApiResponse";

export interface DomainConfigMessagingServiceContext {
  /**
   * Fetch a DomainConfigMessagingServiceInstance
   *
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed DomainConfigMessagingServiceInstance
   */
  fetch(
    callback?: (
      error: Error | null,
      item?: DomainConfigMessagingServiceInstance
    ) => any
  ): Promise<DomainConfigMessagingServiceInstance>;

  /**
   * Fetch a DomainConfigMessagingServiceInstance and return HTTP info
   *
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed DomainConfigMessagingServiceInstance with HTTP metadata
   */
  fetchWithHttpInfo(
    callback?: (
      error: Error | null,
      item?: ApiResponse<DomainConfigMessagingServiceInstance>
    ) => any
  ): Promise<ApiResponse<DomainConfigMessagingServiceInstance>>;

  /**
   * Provide a user-friendly representation
   */
  toJSON(): any;
  [inspect.custom](_depth: any, options: InspectOptions): any;
}

export interface DomainConfigMessagingServiceContextSolution {
  messagingServiceSid: string;
}

export class DomainConfigMessagingServiceContextImpl
  implements DomainConfigMessagingServiceContext
{
  protected _solution: DomainConfigMessagingServiceContextSolution;
  protected _uri: string;

  constructor(protected _version: V1, messagingServiceSid: string) {
    if (!isValidPathParam(messagingServiceSid)) {
      throw new Error("Parameter 'messagingServiceSid' is not valid.");
    }

    this._solution = { messagingServiceSid };
    this._uri = `/LinkShortening/MessagingService/${messagingServiceSid}/DomainConfig`;
  }

  fetch(
    callback?: (
      error: Error | null,
      item?: DomainConfigMessagingServiceInstance
    ) => any
  ): Promise<DomainConfigMessagingServiceInstance> {
    const headers: any = {};
    headers["Accept"] = "application/json";

    const instance = this;
    let operationVersion = instance._version,
      operationPromise = operationVersion.fetch({
        uri: instance._uri,
        method: "get",
        headers,
      });

    operationPromise = operationPromise.then(
      (payload) =>
        new DomainConfigMessagingServiceInstance(
          operationVersion,
          payload,
          instance._solution.messagingServiceSid
        )
    );

    operationPromise = instance._version.setPromiseCallback(
      operationPromise,
      callback
    );
    return operationPromise;
  }

  fetchWithHttpInfo(
    callback?: (
      error: Error | null,
      item?: ApiResponse<DomainConfigMessagingServiceInstance>
    ) => any
  ): Promise<ApiResponse<DomainConfigMessagingServiceInstance>> {
    const headers: any = {};
    headers["Accept"] = "application/json";

    const instance = this;
    let operationVersion = instance._version;
    // CREATE, FETCH, UPDATE operations
    let operationPromise = operationVersion
      .fetchWithResponseInfo<DomainConfigMessagingServiceResource>({
        uri: instance._uri,
        method: "get",
        headers,
      })
      .then(
        (response): ApiResponse<DomainConfigMessagingServiceInstance> => ({
          ...response,
          body: new DomainConfigMessagingServiceInstance(
            operationVersion,
            response.body,
            instance._solution.messagingServiceSid
          ),
        })
      );

    operationPromise = instance._version.setPromiseCallback(
      operationPromise,
      callback
    );
    return operationPromise;
  }

  /**
   * Provide a user-friendly representation
   *
   * @returns Object
   */
  toJSON() {
    return this._solution;
  }

  [inspect.custom](_depth: any, options: InspectOptions) {
    return inspect(this.toJSON(), options);
  }
}

interface DomainConfigMessagingServicePayload
  extends DomainConfigMessagingServiceResource {}

interface DomainConfigMessagingServiceResource {
  domain_sid: string;
  config_sid: string;
  messaging_service_sid: string;
  fallback_url: string;
  callback_url: string;
  continue_on_failure: boolean;
  date_created: Date;
  date_updated: Date;
  url: string;
}

export class DomainConfigMessagingServiceInstance {
  protected _solution: DomainConfigMessagingServiceContextSolution;
  protected _context?: DomainConfigMessagingServiceContext;

  constructor(
    protected _version: V1,
    payload: DomainConfigMessagingServiceResource,
    messagingServiceSid?: string
  ) {
    this.domainSid = payload.domain_sid;
    this.configSid = payload.config_sid;
    this.messagingServiceSid = payload.messaging_service_sid;
    this.fallbackUrl = payload.fallback_url;
    this.callbackUrl = payload.callback_url;
    this.continueOnFailure = payload.continue_on_failure;
    this.dateCreated = deserialize.iso8601DateTime(payload.date_created);
    this.dateUpdated = deserialize.iso8601DateTime(payload.date_updated);
    this.url = payload.url;

    this._solution = {
      messagingServiceSid: messagingServiceSid || this.messagingServiceSid,
    };
  }

  /**
   * The unique string that we created to identify the Domain resource.
   */
  domainSid: string;
  /**
   * The unique string that we created to identify the Domain config (prefix ZK).
   */
  configSid: string;
  /**
   * The unique string that identifies the messaging service
   */
  messagingServiceSid: string;
  /**
   * Any requests we receive to this domain that do not match an existing shortened message will be redirected to the fallback url. These will likely be either expired messages, random misdirected traffic, or intentional scraping.
   */
  fallbackUrl: string;
  /**
   * URL to receive click events to your webhook whenever the recipients click on the shortened links.
   */
  callbackUrl: string;
  /**
   * Boolean field to set customer delivery preference when there is a failure in linkShortening service
   */
  continueOnFailure: boolean;
  /**
   * Date this Domain Config was created.
   */
  dateCreated: Date;
  /**
   * Date that this Domain Config was last updated.
   */
  dateUpdated: Date;
  url: string;

  private get _proxy(): DomainConfigMessagingServiceContext {
    this._context =
      this._context ||
      new DomainConfigMessagingServiceContextImpl(
        this._version,
        this._solution.messagingServiceSid
      );
    return this._context;
  }

  /**
   * Fetch a DomainConfigMessagingServiceInstance
   *
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed DomainConfigMessagingServiceInstance
   */
  fetch(
    callback?: (
      error: Error | null,
      item?: DomainConfigMessagingServiceInstance
    ) => any
  ): Promise<DomainConfigMessagingServiceInstance> {
    return this._proxy.fetch(callback);
  }

  /**
   * Fetch a DomainConfigMessagingServiceInstance and return HTTP info
   *
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed DomainConfigMessagingServiceInstance with HTTP metadata
   */
  fetchWithHttpInfo(
    callback?: (
      error: Error | null,
      item?: ApiResponse<DomainConfigMessagingServiceInstance>
    ) => any
  ): Promise<ApiResponse<DomainConfigMessagingServiceInstance>> {
    return this._proxy.fetchWithHttpInfo(callback);
  }

  /**
   * Provide a user-friendly representation
   *
   * @returns Object
   */
  toJSON() {
    return {
      domainSid: this.domainSid,
      configSid: this.configSid,
      messagingServiceSid: this.messagingServiceSid,
      fallbackUrl: this.fallbackUrl,
      callbackUrl: this.callbackUrl,
      continueOnFailure: this.continueOnFailure,
      dateCreated: this.dateCreated,
      dateUpdated: this.dateUpdated,
      url: this.url,
    };
  }

  [inspect.custom](_depth: any, options: InspectOptions) {
    return inspect(this.toJSON(), options);
  }
}

export interface DomainConfigMessagingServiceSolution {}

export interface DomainConfigMessagingServiceListInstance {
  _version: V1;
  _solution: DomainConfigMessagingServiceSolution;
  _uri: string;

  (messagingServiceSid: string): DomainConfigMessagingServiceContext;
  get(messagingServiceSid: string): DomainConfigMessagingServiceContext;

  /**
   * Provide a user-friendly representation
   */
  toJSON(): any;
  [inspect.custom](_depth: any, options: InspectOptions): any;
}

export function DomainConfigMessagingServiceListInstance(
  version: V1
): DomainConfigMessagingServiceListInstance {
  const instance = ((messagingServiceSid) =>
    instance.get(
      messagingServiceSid
    )) as DomainConfigMessagingServiceListInstance;

  instance.get = function get(
    messagingServiceSid
  ): DomainConfigMessagingServiceContext {
    return new DomainConfigMessagingServiceContextImpl(
      version,
      messagingServiceSid
    );
  };

  instance._version = version;
  instance._solution = {};
  instance._uri = ``;

  instance.toJSON = function toJSON() {
    return instance._solution;
  };

  instance[inspect.custom] = function inspectImpl(
    _depth: any,
    options: InspectOptions
  ) {
    return inspect(instance.toJSON(), options);
  };

  return instance;
}
