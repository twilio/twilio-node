/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Organization Public API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { inspect, InspectOptions } from "util";
import Page, { TwilioResponsePayload } from "../../../../base/Page";
import Response from "../../../../http/response";
import Versionless from "../../Versionless";
const deserialize = require("../../../../base/deserialize");
const serialize = require("../../../../base/serialize");
import { isValidPathParam } from "../../../../base/utility";

/**
 * Email address list of the user. Primary email must be defined if there are more than 1 email. Primary email must match the username.
 */
export class ScimEmailAddress {
  /**
   * Indicates if this email address is the primary one
   */
  "primary"?: boolean;
  /**
   * The actual email address value
   */
  "value"?: string;
  /**
   * The type of email address (e.g., work, home, etc.)
   */
  "type"?: string;
}

/**
 * Meta
 */
export class ScimMeta {
  /**
   * Indicates the type of the resource
   */
  "resourceType"?: string;
  /**
   * The date and time when the resource was created in the system
   */
  "created"?: Date;
  /**
   * The date and time when the resource was last modified
   */
  "lastModified"?: Date;
  /**
   * A version identifier for the resource. This can be used to manage resource versioning and concurrency control.
   */
  "version"?: string;
}

/**
 * User\'s name
 */
export class ScimName {
  /**
   * The user\'s first or given name
   */
  "givenName"?: string;
  /**
   * The user\'s last or family name
   */
  "familyName"?: string;
}

export class ScimUser {
  /**
   * Unique Twilio user sid
   */
  "id"?: string;
  /**
   * External unique resource id defined by provisioning client
   */
  "externalId"?: string;
  /**
   * Unique username, MUST be same as primary email address
   */
  "userName": string;
  /**
   * User friendly display name
   */
  "displayName"?: string;
  "name"?: ScimName;
  /**
   * Email address list of the user. Primary email must be defined if there are more than 1 email. Primary email must match the username.
   */
  "emails"?: Array<ScimEmailAddress>;
  /**
   * Indicates whether the user is active
   */
  "active"?: boolean;
  /**
   * User\'s locale
   */
  "locale"?: string;
  /**
   * User\'s time zone
   */
  "timezone"?: string;
  /**
   * An array of URIs that indicate the schemas supported for this user resource
   */
  "schemas"?: Array<string>;
  "meta"?: ScimMeta;
  /**
   * A human-readable description of the error
   */
  "detail"?: string;
  /**
   * A scimType error code as defined in RFC7644
   */
  "scimType"?: string;
  /**
   * Http status code
   */
  "status"?: string;
  /**
   * Twilio-specific error code
   */
  "code"?: number;
  /**
   * Link to Error Code References
   */
  "moreInfo"?: string;
}

/**
 * Options to pass to update a UserInstance
 */
export interface UserContextUpdateOptions {
  /**  */
  scimUser: ScimUser;
  /**  */
  ifMatch?: string;
}

/**
 * Options to pass to create a UserInstance
 */
export interface UserListInstanceCreateOptions {
  /**  */
  scimUser: ScimUser;
}
/**
 * Options to pass to each
 */
export interface UserListInstanceEachOptions {
  /**  */
  filter?: string;
  /** Function to process each record. If this and a positional callback are passed, this one will be used */
  callback?: (item: UserInstance, done: (err?: Error) => void) => void;
  /** Function to be called upon completion of streaming */
  done?: Function;
  /** Upper limit for the number of records to return. each() guarantees never to return more than limit. Default is no limit */
  limit?: number;
}

/**
 * Options to pass to list
 */
export interface UserListInstanceOptions {
  /**  */
  filter?: string;
  /** Upper limit for the number of records to return. list() guarantees never to return more than limit. Default is no limit */
  limit?: number;
}

/**
 * Options to pass to page
 */
export interface UserListInstancePageOptions {
  /**  */
  filter?: string;
  /** Page Number, this value is simply for client state */
  pageNumber?: number;
  /** PageToken provided by the API */
  pageToken?: string;
}

export interface UserContext {
  /**
   * Remove a UserInstance
   *
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed boolean
   */
  remove(
    callback?: (error: Error | null, item?: boolean) => any
  ): Promise<boolean>;

  /**
   * Fetch a UserInstance
   *
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed UserInstance
   */
  fetch(
    callback?: (error: Error | null, item?: UserInstance) => any
  ): Promise<UserInstance>;

  /**
   * Update a UserInstance
   *
   * @param params - Body for request
   * @param headers - header params for request
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed UserInstance
   */
  update(
    params: ScimUser,
    headers?: any,
    callback?: (error: Error | null, item?: UserInstance) => any
  ): Promise<UserInstance>;

  /**
   * Provide a user-friendly representation
   */
  toJSON(): any;
  [inspect.custom](_depth: any, options: InspectOptions): any;
}

export interface UserContextSolution {
  organizationSid: string;
  id: string;
}

export class UserContextImpl implements UserContext {
  protected _solution: UserContextSolution;
  protected _uri: string;

  constructor(
    protected _version: Versionless,
    organizationSid: string,
    id: string
  ) {
    if (!isValidPathParam(organizationSid)) {
      throw new Error("Parameter 'organizationSid' is not valid.");
    }

    if (!isValidPathParam(id)) {
      throw new Error("Parameter 'id' is not valid.");
    }

    this._solution = { organizationSid, id };
    this._uri = `/${organizationSid}/scim/Users/${id}`;
  }

  remove(
    callback?: (error: Error | null, item?: boolean) => any
  ): Promise<boolean> {
    const headers: any = {};

    const instance = this;
    let operationVersion = instance._version,
      operationPromise = operationVersion.remove({
        uri: instance._uri,
        method: "delete",
        headers,
      });

    operationPromise = instance._version.setPromiseCallback(
      operationPromise,
      callback
    );
    return operationPromise;
  }

  async fetch(
    callback?: (error: Error | null, item?: UserInstance) => any
  ): Promise<UserInstance> {
    const headers: any = {};
    headers["Accept"] = "application/scim+json";

    const instance = this;
    let operationVersion = instance._version,
      operationPromise = operationVersion.fetch({
        uri: instance._uri,
        method: "get",
        headers,
      });

    try {
      let payload = await operationPromise;
      let operation = new UserInstance(
        operationVersion,
        payload,
        instance._solution.organizationSid,
        instance._solution.id
      );

      if (callback) {
        callback(null, operation);
      }

      return operation;
    } catch (err: any) {
      if (callback) {
        callback(err);
      }
      throw err;
    }
  }

  async update(
    params: ScimUser,
    headers?: any,
    callback?: (error: Error | null, item?: UserInstance) => any
  ): Promise<UserInstance> {
    if (params === null || params === undefined) {
      throw new Error('Required parameter "params" missing.');
    }

    let data: any = {};

    data = params;

    if (headers === null || headers === undefined) {
      headers = {};
    }

    headers["Content-Type"] = "application/json";
    headers["Accept"] = "application/scim+json";

    const instance = this;
    let operationVersion = instance._version,
      operationPromise = operationVersion.update({
        uri: instance._uri,
        method: "put",
        data,
        headers,
      });

    try {
      let payload = await operationPromise;
      let operation = new UserInstance(
        operationVersion,
        payload,
        instance._solution.organizationSid,
        instance._solution.id
      );

      if (callback) {
        callback(null, operation);
      }

      return operation;
    } catch (err: any) {
      if (callback) {
        callback(err);
      }
      throw err;
    }
  }

  /**
   * Provide a user-friendly representation
   *
   * @returns Object
   */
  toJSON() {
    return this._solution;
  }

  [inspect.custom](_depth: any, options: InspectOptions) {
    return inspect(this.toJSON(), options);
  }
}

interface UserPayload extends TwilioResponsePayload {
  Resources: UserResource[];
}

interface UserResource {
  id: string;
  externalId: string;
  userName: string;
  displayName: string;
  name: ScimName;
  emails: Array<ScimEmailAddress>;
  active: boolean;
  locale: string;
  timezone: string;
  schemas: Array<string>;
  meta: ScimMeta;
  detail: string;
  scimType: string;
  status: string;
  code: number;
  moreInfo: string;
}

export class UserInstance {
  protected _solution: UserContextSolution;
  protected _context?: UserContext;

  constructor(
    protected _version: Versionless,
    payload: UserResource,
    organizationSid: string,
    id?: string
  ) {
    this.id = payload.id;
    this.externalId = payload.externalId;
    this.userName = payload.userName;
    this.displayName = payload.displayName;
    this.name = payload.name;
    this.emails = payload.emails;
    this.active = payload.active;
    this.locale = payload.locale;
    this.timezone = payload.timezone;
    this.schemas = payload.schemas;
    this.meta = payload.meta;
    this.detail = payload.detail;
    this.scimType = payload.scimType;
    this.status = payload.status;
    this.code = payload.code;
    this.moreInfo = payload.moreInfo;

    this._solution = { organizationSid, id: id || this.id };
  }

  /**
   * Unique Twilio user sid
   */
  id: string;
  /**
   * External unique resource id defined by provisioning client
   */
  externalId: string;
  /**
   * Unique username, MUST be same as primary email address
   */
  userName: string;
  /**
   * User friendly display name
   */
  displayName: string;
  name: ScimName;
  /**
   * Email address list of the user. Primary email must be defined if there are more than 1 email. Primary email must match the username.
   */
  emails: Array<ScimEmailAddress>;
  /**
   * Indicates whether the user is active
   */
  active: boolean;
  /**
   * User\'s locale
   */
  locale: string;
  /**
   * User\'s time zone
   */
  timezone: string;
  /**
   * An array of URIs that indicate the schemas supported for this user resource
   */
  schemas: Array<string>;
  meta: ScimMeta;
  /**
   * A human-readable description of the error
   */
  detail: string;
  /**
   * A scimType error code as defined in RFC7644
   */
  scimType: string;
  /**
   * Http status code
   */
  status: string;
  /**
   * Twilio-specific error code
   */
  code: number;
  /**
   * Link to Error Code References
   */
  moreInfo: string;

  private get _proxy(): UserContext {
    this._context =
      this._context ||
      new UserContextImpl(
        this._version,
        this._solution.organizationSid,
        this._solution.id
      );
    return this._context;
  }

  /**
   * Remove a UserInstance
   *
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed boolean
   */
  remove(
    callback?: (error: Error | null, item?: boolean) => any
  ): Promise<boolean> {
    return this._proxy.remove(callback);
  }

  /**
   * Fetch a UserInstance
   *
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed UserInstance
   */
  fetch(
    callback?: (error: Error | null, item?: UserInstance) => any
  ): Promise<UserInstance> {
    return this._proxy.fetch(callback);
  }

  /**
   * Update a UserInstance
   *
   * @param params - Body for request
   * @param headers - header params for request
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed UserInstance
   */
  update(
    params: ScimUser,
    headers?: any,
    callback?: (error: Error | null, item?: UserInstance) => any
  ): Promise<UserInstance>;

  update(
    params?: any,
    callback?: (error: Error | null, item?: UserInstance) => any
  ): Promise<UserInstance> {
    return this._proxy.update(params, callback);
  }

  /**
   * Provide a user-friendly representation
   *
   * @returns Object
   */
  toJSON() {
    return {
      id: this.id,
      externalId: this.externalId,
      userName: this.userName,
      displayName: this.displayName,
      name: this.name,
      emails: this.emails,
      active: this.active,
      locale: this.locale,
      timezone: this.timezone,
      schemas: this.schemas,
      meta: this.meta,
      detail: this.detail,
      scimType: this.scimType,
      status: this.status,
      code: this.code,
      moreInfo: this.moreInfo,
    };
  }

  [inspect.custom](_depth: any, options: InspectOptions) {
    return inspect(this.toJSON(), options);
  }
}

export interface UserSolution {
  organizationSid: string;
}

export interface UserListInstance {
  _version: Versionless;
  _solution: UserSolution;
  _uri: string;

  (id: string): UserContext;
  get(id: string): UserContext;

  /**
   * Create a UserInstance
   *
   * @param params - Body for request
   * @param headers - header params for request
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed UserInstance
   */
  create(
    params: ScimUser,
    headers?: any,
    callback?: (error: Error | null, item?: UserInstance) => any
  ): Promise<UserInstance>;

  /**
   * Streams UserInstance records from the API.
   *
   * This operation lazily loads records as efficiently as possible until the limit
   * is reached.
   *
   * The results are passed into the callback function, so this operation is memory
   * efficient.
   *
   * If a function is passed as the first argument, it will be used as the callback
   * function.
   *
   * @param { UserListInstanceEachOptions } [params] - Options for request
   * @param { function } [callback] - Function to process each record
   */
  each(
    callback?: (item: UserInstance, done: (err?: Error) => void) => void
  ): void;
  each(
    params: UserListInstanceEachOptions,
    callback?: (item: UserInstance, done: (err?: Error) => void) => void
  ): void;
  /**
   * Retrieve a single target page of UserInstance records from the API.
   *
   * The request is executed immediately.
   *
   * @param { string } [targetUrl] - API-generated URL for the requested results page
   * @param { function } [callback] - Callback to handle list of records
   */
  getPage(
    targetUrl: string,
    callback?: (error: Error | null, items: UserPage) => any
  ): Promise<UserPage>;
  /**
   * Lists UserInstance records from the API as a list.
   *
   * If a function is passed as the first argument, it will be used as the callback
   * function.
   *
   * @param { UserListInstanceOptions } [params] - Options for request
   * @param { function } [callback] - Callback to handle list of records
   */
  list(
    callback?: (error: Error | null, items: UserInstance[]) => any
  ): Promise<UserInstance[]>;
  list(
    params: UserListInstanceOptions,
    callback?: (error: Error | null, items: UserInstance[]) => any
  ): Promise<UserInstance[]>;
  /**
   * Retrieve a single page of UserInstance records from the API.
   *
   * The request is executed immediately.
   *
   * If a function is passed as the first argument, it will be used as the callback
   * function.
   *
   * @param { UserListInstancePageOptions } [params] - Options for request
   * @param { function } [callback] - Callback to handle list of records
   */
  page(
    callback?: (error: Error | null, items: UserPage) => any
  ): Promise<UserPage>;
  page(
    params: UserListInstancePageOptions,
    callback?: (error: Error | null, items: UserPage) => any
  ): Promise<UserPage>;

  /**
   * Provide a user-friendly representation
   */
  toJSON(): any;
  [inspect.custom](_depth: any, options: InspectOptions): any;
}

export function UserListInstance(
  version: Versionless,
  organizationSid: string
): UserListInstance {
  if (!isValidPathParam(organizationSid)) {
    throw new Error("Parameter 'organizationSid' is not valid.");
  }

  const instance = ((id) => instance.get(id)) as UserListInstance;

  instance.get = function get(id): UserContext {
    return new UserContextImpl(version, organizationSid, id);
  };

  instance._version = version;
  instance._solution = { organizationSid };
  instance._uri = `/${organizationSid}/scim/Users`;

  instance.create = function create(
    params: ScimUser,
    headers?: any,
    callback?: (error: Error | null, items: UserInstance) => any
  ): Promise<UserInstance> {
    if (params === null || params === undefined) {
      throw new Error('Required parameter "params" missing.');
    }

    let data: any = {};

    data = params;

    if (headers === null || headers === undefined) {
      headers = {};
    }

    headers["Content-Type"] = "application/json";
    headers["Accept"] = "application/scim+json";

    let operationVersion = version,
      operationPromise = operationVersion.create({
        uri: instance._uri,
        method: "post",
        data,
        headers,
      });

    operationPromise = operationPromise.then(
      (payload) =>
        new UserInstance(
          operationVersion,
          payload,
          instance._solution.organizationSid
        )
    );

    operationPromise = instance._version.setPromiseCallback(
      operationPromise,
      callback
    );
    return operationPromise;
  };

  instance.page = function page(
    params?:
      | UserListInstancePageOptions
      | ((error: Error | null, items: UserPage) => any),
    callback?: (error: Error | null, items: UserPage) => any
  ): Promise<UserPage> {
    if (params instanceof Function) {
      callback = params;
      params = {};
    } else {
      params = params || {};
    }

    let data: any = {};

    if (params["filter"] !== undefined) data["filter"] = params["filter"];

    if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
    if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;

    const headers: any = {};
    headers["Accept"] = "application/scim+json";

    let operationVersion = version,
      operationPromise = operationVersion.page({
        uri: instance._uri,
        method: "get",
        params: data,
        headers,
      });

    operationPromise = operationPromise.then(
      (payload) => new UserPage(operationVersion, payload, instance._solution)
    );

    operationPromise = instance._version.setPromiseCallback(
      operationPromise,
      callback
    );
    return operationPromise;
  };
  instance.each = instance._version.each;
  instance.list = instance._version.list;

  instance.getPage = function getPage(
    targetUrl: string,
    callback?: (error: Error | null, items: UserPage) => any
  ): Promise<UserPage> {
    const operationPromise = instance._version._domain.twilio.request({
      method: "get",
      uri: targetUrl,
    });

    let pagePromise = operationPromise.then(
      (payload) => new UserPage(instance._version, payload, instance._solution)
    );
    pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
    return pagePromise;
  };

  instance.toJSON = function toJSON() {
    return instance._solution;
  };

  instance[inspect.custom] = function inspectImpl(
    _depth: any,
    options: InspectOptions
  ) {
    return inspect(instance.toJSON(), options);
  };

  return instance;
}

export class UserPage extends Page<
  Versionless,
  UserPayload,
  UserResource,
  UserInstance
> {
  /**
   * Initialize the UserPage
   *
   * @param version - Version of the resource
   * @param response - Response from the API
   * @param solution - Path solution
   */
  constructor(
    version: Versionless,
    response: Response<string>,
    solution: UserSolution
  ) {
    super(version, response, solution);
  }

  /**
   * Build an instance of UserInstance
   *
   * @param payload - Payload response from the API
   */
  getInstance(payload: UserResource): UserInstance {
    return new UserInstance(
      this._version,
      payload,
      this._solution.organizationSid
    );
  }

  [inspect.custom](depth: any, options: InspectOptions) {
    return inspect(this.toJSON(), options);
  }
}
