/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Numbers
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { inspect, InspectOptions } from "util";
import V1 from "../V1";
const deserialize = require("../../../base/deserialize");
const serialize = require("../../../base/serialize");
import { isValidPathParam } from "../../../base/utility";
import { ApiResponse } from "../../../base/ApiResponse";

/**
 * Options to pass to create a PortingWebhookConfigurationInstance
 */
export interface PortingWebhookConfigurationListInstanceCreateOptions {
  /**  */
  body?: object;
}

export interface PortingWebhookConfigurationSolution {}

export interface PortingWebhookConfigurationListInstance {
  _version: V1;
  _solution: PortingWebhookConfigurationSolution;
  _uri: string;

  /**
   * Create a PortingWebhookConfigurationInstance
   *
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed PortingWebhookConfigurationInstance
   */
  create(
    callback?: (
      error: Error | null,
      item?: PortingWebhookConfigurationInstance
    ) => any
  ): Promise<PortingWebhookConfigurationInstance>;
  /**
   * Create a PortingWebhookConfigurationInstance
   *
   * @param params - Body for request
   * @param headers - header params for request
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed PortingWebhookConfigurationInstance
   */
  create(
    params: object,
    headers?: any,
    callback?: (
      error: Error | null,
      item?: PortingWebhookConfigurationInstance
    ) => any
  ): Promise<PortingWebhookConfigurationInstance>;

  /**
   * Create a PortingWebhookConfigurationInstance and return HTTP info
   *
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed PortingWebhookConfigurationInstance with HTTP metadata
   */
  createWithHttpInfo(
    callback?: (
      error: Error | null,
      item?: ApiResponse<PortingWebhookConfigurationInstance>
    ) => any
  ): Promise<ApiResponse<PortingWebhookConfigurationInstance>>;
  /**
   * Create a PortingWebhookConfigurationInstance and return HTTP info
   *
   * @param params - Body for request
   * @param headers - header params for request
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed PortingWebhookConfigurationInstance with HTTP metadata
   */
  createWithHttpInfo(
    params: object,
    headers?: any,
    callback?: (
      error: Error | null,
      item?: ApiResponse<PortingWebhookConfigurationInstance>
    ) => any
  ): Promise<ApiResponse<PortingWebhookConfigurationInstance>>;

  /**
   * Provide a user-friendly representation
   */
  toJSON(): any;
  [inspect.custom](_depth: any, options: InspectOptions): any;
}

export function PortingWebhookConfigurationListInstance(
  version: V1
): PortingWebhookConfigurationListInstance {
  const instance = {} as PortingWebhookConfigurationListInstance;

  instance._version = version;
  instance._solution = {};
  instance._uri = `/Porting/Configuration/Webhook`;

  instance.create = function create(
    params?:
      | object
      | ((
          error: Error | null,
          items: PortingWebhookConfigurationInstance
        ) => any),
    headers?: any,
    callback?: (
      error: Error | null,
      items: PortingWebhookConfigurationInstance
    ) => any
  ): Promise<PortingWebhookConfigurationInstance> {
    if (params instanceof Function) {
      callback = params;
      params = {};
    } else {
      params = params || {};
    }

    let data: any = {};

    data = params;

    if (headers === null || headers === undefined) {
      headers = {};
    }

    headers["Content-Type"] = "application/json";
    headers["Accept"] = "application/json";

    let operationVersion = version,
      operationPromise = operationVersion.create({
        uri: instance._uri,
        method: "post",
        data,
        headers,
      });

    operationPromise = operationPromise.then(
      (payload) =>
        new PortingWebhookConfigurationInstance(operationVersion, payload)
    );

    operationPromise = instance._version.setPromiseCallback(
      operationPromise,
      callback
    );
    return operationPromise;
  };

  instance.createWithHttpInfo = function createWithHttpInfo(
    params?:
      | object
      | ((
          error: Error | null,
          items: ApiResponse<PortingWebhookConfigurationInstance>
        ) => any),
    headers?: any,
    callback?: (
      error: Error | null,
      items: ApiResponse<PortingWebhookConfigurationInstance>
    ) => any
  ): Promise<ApiResponse<PortingWebhookConfigurationInstance>> {
    if (params instanceof Function) {
      callback = params;
      params = {};
    } else {
      params = params || {};
    }

    let data: any = {};

    data = params;

    if (headers === null || headers === undefined) {
      headers = {};
    }

    headers["Content-Type"] = "application/json";
    headers["Accept"] = "application/json";

    let operationVersion = version;
    // CREATE, FETCH, UPDATE operations
    let operationPromise = operationVersion
      .createWithResponseInfo<PortingWebhookConfigurationResource>({
        uri: instance._uri,
        method: "post",
        data,
        headers,
      })
      .then(
        (response): ApiResponse<PortingWebhookConfigurationInstance> => ({
          ...response,
          body: new PortingWebhookConfigurationInstance(
            operationVersion,
            response.body
          ),
        })
      );

    operationPromise = instance._version.setPromiseCallback(
      operationPromise,
      callback
    );
    return operationPromise;
  };

  instance.toJSON = function toJSON() {
    return instance._solution;
  };

  instance[inspect.custom] = function inspectImpl(
    _depth: any,
    options: InspectOptions
  ) {
    return inspect(instance.toJSON(), options);
  };

  return instance;
}

interface PortingWebhookConfigurationPayload
  extends PortingWebhookConfigurationResource {}

interface PortingWebhookConfigurationResource {
  url: string;
  port_in_target_url: string;
  port_out_target_url: string;
  notifications_of: Array<string>;
}

export class PortingWebhookConfigurationInstance {
  constructor(
    protected _version: V1,
    payload: PortingWebhookConfigurationResource
  ) {
    this.url = payload.url;
    this.portInTargetUrl = payload.port_in_target_url;
    this.portOutTargetUrl = payload.port_out_target_url;
    this.notificationsOf = payload.notifications_of;
  }

  /**
   * The URL of the webhook configuration request
   */
  url: string;
  /**
   * The complete webhook url that will be called when a notification event for port in request or port in phone number happens
   */
  portInTargetUrl: string;
  /**
   * The complete webhook url that will be called when a notification event for a port out phone number happens.
   */
  portOutTargetUrl: string;
  /**
   * A list to filter what notification events to receive for this account and its sub accounts. If it is an empty list, then it means that there are no filters for the notifications events to send in each webhook and all events will get sent.
   */
  notificationsOf: Array<string>;

  /**
   * Provide a user-friendly representation
   *
   * @returns Object
   */
  toJSON() {
    return {
      url: this.url,
      portInTargetUrl: this.portInTargetUrl,
      portOutTargetUrl: this.portOutTargetUrl,
      notificationsOf: this.notificationsOf,
    };
  }

  [inspect.custom](_depth: any, options: InspectOptions) {
    return inspect(this.toJSON(), options);
  }
}
