/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Insights
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { inspect, InspectOptions } from "util";
import Page from "../../../../base/Page";
import Response from "../../../../http/response";
import V1 from "../../V1";
const deserialize = require("../../../../base/deserialize");
const serialize = require("../../../../base/serialize");


/**
 * Options to pass to create a AnnotationInstance
 *
 * @property { AnnotationEnumAnsweredBy } [answeredBy] 
 * @property { AnnotationEnumConnectivityIssue } [connectivityIssue] 
 * @property { string } [qualityIssues] Specify if the call had any subjective quality issues. Possible values, one or more of:  no_quality_issue, low_volume, choppy_robotic, echo, dtmf, latency, owa, static_noise. Use comma separated values to indicate multiple quality issues for the same call
 * @property { boolean } [spam] Specify if the call was a spam call. Use this to provide feedback on whether calls placed from your account were marked as spam, or if inbound calls received by your account were unwanted spam. Is of type Boolean: true, false. Use true if the call was a spam call.
 * @property { number } [callScore] Specify the call score. This is of type integer. Use a range of 1-5 to indicate the call experience score, with the following mapping as a reference for rating the call [5: Excellent, 4: Good, 3 : Fair, 2 : Poor, 1: Bad].
 * @property { string } [comment] Specify any comments pertaining to the call. This of type string with a max limit of 100 characters. Twilio does not treat this field as PII, so don’t put any PII in here.
 * @property { string } [incident] Associate this call with an incident or support ticket. This is of type string with a max limit of 100 characters. Twilio does not treat this field as PII, so don’t put any PII in here.
 */
export interface AnnotationListInstanceCreateOptions {
  answeredBy?: AnnotationEnumAnsweredBy;
  connectivityIssue?: AnnotationEnumConnectivityIssue;
  qualityIssues?: string;
  spam?: boolean;
  callScore?: number;
  comment?: string;
  incident?: string;
}

export interface AnnotationListInstance {



  /**
   * Streams AnnotationInstance records from the API.
   *
   * This operation lazily loads records as efficiently as possible until the limit
   * is reached.
   *
   * The results are passed into the callback function, so this operation is memory
   * efficient.
   *
   * If a function is passed as the first argument, it will be used as the callback
   * function.
   *
   * @param { function } [callback] - Function to process each record
   */
  each(callback?: (item: AnnotationInstance, done: (err?: Error) => void) => void): void;
  /**
   * Streams AnnotationInstance records from the API.
   *
   * This operation lazily loads records as efficiently as possible until the limit
   * is reached.
   *
   * The results are passed into the callback function, so this operation is memory
   * efficient.
   *
   * If a function is passed as the first argument, it will be used as the callback
   * function.
   *
   * @param { AnnotationListInstanceEachOptions } [params] - Options for request
   * @param { function } [callback] - Function to process each record
   */
  each(params?: AnnotationListInstanceEachOptions, callback?: (item: AnnotationInstance, done: (err?: Error) => void) => void): void;
  each(params?: any, callback?: any): void;
  /**
   * Retrieve a single target page of AnnotationInstance records from the API.
   *
   * The request is executed immediately.
   *
   * If a function is passed as the first argument, it will be used as the callback
   * function.
   *
   * @param { function } [callback] - Callback to handle list of records
   */
  getPage(callback?: (error: Error | null, items: AnnotationPage) => any): Promise<AnnotationPage>;
  /**
   * Retrieve a single target page of AnnotationInstance records from the API.
   *
   * The request is executed immediately.
   *
   * If a function is passed as the first argument, it will be used as the callback
   * function.
   *
   * @param { string } [targetUrl] - API-generated URL for the requested results page
   * @param { function } [callback] - Callback to handle list of records
   */
  getPage(targetUrl?: string, callback?: (error: Error | null, items: AnnotationPage) => any): Promise<AnnotationPage>;
  getPage(params?: any, callback?: any): Promise<AnnotationPage>;
  /**
   * Lists AnnotationInstance records from the API as a list.
   *
   * If a function is passed as the first argument, it will be used as the callback
   * function.
   *
   * @param { function } [callback] - Callback to handle list of records
   */
  list(callback?: (error: Error | null, items: AnnotationInstance[]) => any): Promise<AnnotationInstance[]>;
  /**
   * Lists AnnotationInstance records from the API as a list.
   *
   * If a function is passed as the first argument, it will be used as the callback
   * function.
   *
   * @param { AnnotationListInstanceOptions } [params] - Options for request
   * @param { function } [callback] - Callback to handle list of records
   */
  list(params?: AnnotationListInstanceOptions, callback?: (error: Error | null, items: AnnotationInstance[]) => any): Promise<AnnotationInstance[]>;
  list(params?: any, callback?: any): Promise<AnnotationInstance[]>;
  /**
   * Retrieve a single page of AnnotationInstance records from the API.
   *
   * The request is executed immediately.
   *
   * If a function is passed as the first argument, it will be used as the callback
   * function.
   *
   * @param { function } [callback] - Callback to handle list of records
   */
  page(callback?: (error: Error | null, items: AnnotationPage) => any): Promise<AnnotationPage>;
  /**
   * Retrieve a single page of AnnotationInstance records from the API.
   *
   * The request is executed immediately.
   *
   * If a function is passed as the first argument, it will be used as the callback
   * function.
   *
   * @param { AnnotationListInstancePageOptions } [params] - Options for request
   * @param { function } [callback] - Callback to handle list of records
   */
  page(params: AnnotationListInstancePageOptions, callback?: (error: Error | null, items: AnnotationPage) => any): Promise<AnnotationPage>;
  page(params?: any, callback?: any): Promise<AnnotationPage>;

  /**
   * Create a AnnotationInstance
   *
   * @param { function } [callback] - Callback to handle processed record
   *
   * @returns { Promise } Resolves to processed AnnotationInstance
   */
  create(callback?: (error: Error | null, item?: AnnotationInstance) => any): Promise<AnnotationInstance>;
  /**
   * Create a AnnotationInstance
   *
   * @param { AnnotationListInstanceCreateOptions } params - Parameter for request
   * @param { function } [callback] - Callback to handle processed record
   *
   * @returns { Promise } Resolves to processed AnnotationInstance
   */
  create(params: AnnotationListInstanceCreateOptions, callback?: (error: Error | null, item?: AnnotationInstance) => any): Promise<AnnotationInstance>;
  create(params?: any, callback?: any): Promise<AnnotationInstance>


  /**
   * Provide a user-friendly representation
   */
  toJSON(): any;
  [inspect.custom](_depth: any, options: InspectOptions): any;
}

interface AnnotationListInstanceImpl extends AnnotationListInstance {}
class AnnotationListInstanceImpl implements AnnotationListInstance {
  _version?: V1;
  _solution?: AnnotationSolution;
  _uri?: string;

}

export function AnnotationListInstance(version: V1, callSid: string): AnnotationListInstance {
  const instance = {} as AnnotationListInstanceImpl;

  instance._version = version;
  instance._solution = { callSid };
  instance._uri = `/Voice/${callSid}/Annotation`;

  instance.page = function page(callback?: any): Promise<AnnotationPage> {

    let operationVersion = version,
        operationPromise = operationVersion.page({ uri: this._uri, method: 'get' });
    
    operationPromise = operationPromise.then(payload => new AnnotationPage(operationVersion, payload, this._solution));

    operationPromise = this._version.setPromiseCallback(operationPromise,callback);
    return operationPromise;

  }
  instance.each = instance._version.each;
  instance.list = instance._version.list;

  instance.getPage = function getPage(targetUrl?: any, callback?: any): Promise<AnnotationPage> {
    let operationPromise = this._version._domain.twilio.request({method: 'get', uri: targetUrl});

    operationPromise = operationPromise.then(payload => new AnnotationPage(this._version, payload, this._solution));
    operationPromise = this._version.setPromiseCallback(operationPromise,callback);
    return operationPromise;
  }



  instance.create = function create(params?: any, callback?: any): Promise<AnnotationInstance> {
    if (typeof params === "function") {
      callback = params;
      params = {};
    } else {
      params = params || {};
    }

    const data: any = {};

    if (params.answeredBy !== undefined) data['AnsweredBy'] = params.answeredBy;
    if (params.connectivityIssue !== undefined) data['ConnectivityIssue'] = params.connectivityIssue;
    if (params.qualityIssues !== undefined) data['QualityIssues'] = params.qualityIssues;
    if (params.spam !== undefined) data['Spam'] = serialize.bool(params.spam);
    if (params.callScore !== undefined) data['CallScore'] = params.callScore;
    if (params.comment !== undefined) data['Comment'] = params.comment;
    if (params.incident !== undefined) data['Incident'] = params.incident;

    const headers: any = {};
    headers['Content-Type'] = 'application/x-www-form-urlencoded'

    let operationVersion = version,
        operationPromise = operationVersion.create({ uri: this._uri, method: 'post', params: data, headers });
    
    operationPromise = operationPromise.then(payload => new AnnotationInstance(operationVersion, payload, this._solution.callSid));
    

    operationPromise = this._version.setPromiseCallback(operationPromise,callback);
    return operationPromise;



    }

  instance.toJSON = function toJSON() {
    return this._solution;
  }

  instance[inspect.custom] = function inspectImpl(_depth: any, options: InspectOptions) {
    return inspect(this.toJSON(), options);
  }

  return instance;
}

interface AnnotationPayload extends AnnotationResource, Page.TwilioResponsePayload {
}

interface AnnotationResource {
  call_sid?: string | null;
  account_sid?: string | null;
  answered_by?: object;
  connectivity_issue?: object;
  quality_issues?: Array<string> | null;
  spam?: boolean | null;
  call_score?: number | null;
  comment?: string | null;
  incident?: string | null;
  url?: string | null;
}

export class AnnotationInstance {
  protected _solution: AnnotationSolution;
  protected _context?: AnnotationListInstance;

  constructor(protected _version: V1, payload: AnnotationPayload, callSid?: string) {
    this.callSid = payload.call_sid;
    this.accountSid = payload.account_sid;
    this.answeredBy = payload.answered_by;
    this.connectivityIssue = payload.connectivity_issue;
    this.qualityIssues = payload.quality_issues;
    this.spam = payload.spam;
    this.callScore = deserialize.integer(payload.call_score);
    this.comment = payload.comment;
    this.incident = payload.incident;
    this.url = payload.url;

    this._solution = { callSid: callSid || this.callSid };
  }

  /**
   * Call SID.
   */
  callSid?: string | null;
  /**
   * Account SID.
   */
  accountSid?: string | null;
  answeredBy?: object;
  connectivityIssue?: object;
  /**
   * Indicates if the call had audio quality issues.
   */
  qualityIssues?: Array<string> | null;
  /**
   * Call spam indicator
   */
  spam?: boolean | null;
  /**
   * Call Score
   */
  callScore?: number | null;
  /**
   * User comments
   */
  comment?: string | null;
  /**
   * Call tag for incidents or support ticket
   */
  incident?: string | null;
  /**
   * The URL of this resource.
   */
  url?: string | null;

  /**
   * Provide a user-friendly representation
   *
   * @returns Object
   */
  toJSON() {
    return {
      callSid: this.callSid, 
      accountSid: this.accountSid, 
      answeredBy: this.answeredBy, 
      connectivityIssue: this.connectivityIssue, 
      qualityIssues: this.qualityIssues, 
      spam: this.spam, 
      callScore: this.callScore, 
      comment: this.comment, 
      incident: this.incident, 
      url: this.url
    }
  }

  [inspect.custom](_depth: any, options: InspectOptions) {
    return inspect(this.toJSON(), options);
  }
}
export interface AnnotationSolution {
  callSid?: string;
}

export class AnnotationPage extends Page<V1, AnnotationPayload, AnnotationResource, AnnotationInstance> {
  /**
   * Initialize the AnnotationPage
   *
   * @param version - Version of the resource
   * @param response - Response from the API
   * @param solution - Path solution
   */
  constructor(version: V1, response: Response<string>, solution: AnnotationSolution) {
    super(version, response, solution);
  }

  /**
   * Build an instance of AnnotationInstance
   *
   * @param payload - Payload response from the API
   */
  getInstance(payload: AnnotationPayload): AnnotationInstance {
    return new AnnotationInstance(
      this._version,
      payload,
      this._solution.callSid,
    );
  }

  [inspect.custom](depth: any, options: InspectOptions) {
    return inspect(this.toJSON(), options);
  }
}

