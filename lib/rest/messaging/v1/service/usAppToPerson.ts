/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Messaging
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { inspect, InspectOptions } from "util";
import Page, { TwilioResponsePayload } from "../../../../base/Page";
import Response from "../../../../http/response";
import V1 from "../../V1";
const deserialize = require("../../../../base/deserialize");
const serialize = require("../../../../base/serialize");
import { isValidPathParam } from "../../../../base/utility";

/**
 * Options to pass to create a UsAppToPersonInstance
 */
export interface UsAppToPersonListInstanceCreateOptions {
  /** A2P Brand Registration SID */
  brandRegistrationSid: string;
  /** A short description of what this SMS campaign does. Min length: 40 characters. Max length: 4096 characters. */
  description: string;
  /** Required for all Campaigns. Details around how a consumer opts-in to their campaign, therefore giving consent to receive their messages. If multiple opt-in methods can be used for the same campaign, they must all be listed. 40 character minimum. 2048 character maximum. */
  messageFlow: string;
  /** Message samples, at least 1 and up to 5 sample messages (at least 2 for sole proprietor), >=20 chars, <=1024 chars each. */
  messageSamples: Array<string>;
  /** A2P Campaign Use Case. Examples: [ 2FA, EMERGENCY, MARKETING..] */
  usAppToPersonUsecase: string;
  /** Indicates that this SMS campaign will send messages that contain links. */
  hasEmbeddedLinks: boolean;
  /** Indicates that this SMS campaign will send messages that contain phone numbers. */
  hasEmbeddedPhone: boolean;
  /** If end users can text in a keyword to start receiving messages from this campaign, the auto-reply messages sent to the end users must be provided. The opt-in response should include the Brand name, confirmation of opt-in enrollment to a recurring message campaign, how to get help, and clear description of how to opt-out. This field is required if end users can text in a keyword to start receiving messages from this campaign. 20 character minimum. 320 character maximum. */
  optInMessage?: string;
  /** Upon receiving the opt-out keywords from the end users, Twilio customers are expected to send back an auto-generated response, which must provide acknowledgment of the opt-out request and confirmation that no further messages will be sent. It is also recommended that these opt-out messages include the brand name. This field is required if managing opt out keywords yourself (i.e. not using Twilio\\\'s Default or Advanced Opt Out features). 20 character minimum. 320 character maximum. */
  optOutMessage?: string;
  /** When customers receive the help keywords from their end users, Twilio customers are expected to send back an auto-generated response; this may include the brand name and additional support contact information. This field is required if managing help keywords yourself (i.e. not using Twilio\\\'s Default or Advanced Opt Out features). 20 character minimum. 320 character maximum. */
  helpMessage?: string;
  /** If end users can text in a keyword to start receiving messages from this campaign, those keywords must be provided. This field is required if end users can text in a keyword to start receiving messages from this campaign. Values must be alphanumeric. 255 character maximum. */
  optInKeywords?: Array<string>;
  /** End users should be able to text in a keyword to stop receiving messages from this campaign. Those keywords must be provided. This field is required if managing opt out keywords yourself (i.e. not using Twilio\\\'s Default or Advanced Opt Out features). Values must be alphanumeric. 255 character maximum. */
  optOutKeywords?: Array<string>;
  /** End users should be able to text in a keyword to receive help. Those keywords must be provided as part of the campaign registration request. This field is required if managing help keywords yourself (i.e. not using Twilio\\\'s Default or Advanced Opt Out features). Values must be alphanumeric. 255 character maximum. */
  helpKeywords?: Array<string>;
}
/**
 * Options to pass to each
 */
export interface UsAppToPersonListInstanceEachOptions {
  /** How many resources to return in each list page. The default is 50, and the maximum is 1000. */
  pageSize?: number;
  /** Function to process each record. If this and a positional callback are passed, this one will be used */
  callback?: (item: UsAppToPersonInstance, done: (err?: Error) => void) => void;
  /** Function to be called upon completion of streaming */
  done?: Function;
  /** Upper limit for the number of records to return. each() guarantees never to return more than limit. Default is no limit */
  limit?: number;
}

/**
 * Options to pass to list
 */
export interface UsAppToPersonListInstanceOptions {
  /** How many resources to return in each list page. The default is 50, and the maximum is 1000. */
  pageSize?: number;
  /** Upper limit for the number of records to return. list() guarantees never to return more than limit. Default is no limit */
  limit?: number;
}

/**
 * Options to pass to page
 */
export interface UsAppToPersonListInstancePageOptions {
  /** How many resources to return in each list page. The default is 50, and the maximum is 1000. */
  pageSize?: number;
  /** Page Number, this value is simply for client state */
  pageNumber?: number;
  /** PageToken provided by the API */
  pageToken?: string;
}

export interface UsAppToPersonContext {
  /**
   * Remove a UsAppToPersonInstance
   *
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed boolean
   */
  remove(
    callback?: (error: Error | null, item?: boolean) => any
  ): Promise<boolean>;

  /**
   * Fetch a UsAppToPersonInstance
   *
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed UsAppToPersonInstance
   */
  fetch(
    callback?: (error: Error | null, item?: UsAppToPersonInstance) => any
  ): Promise<UsAppToPersonInstance>;

  /**
   * Provide a user-friendly representation
   */
  toJSON(): any;
  [inspect.custom](_depth: any, options: InspectOptions): any;
}

export interface UsAppToPersonContextSolution {
  messagingServiceSid: string;
  sid: string;
}

export class UsAppToPersonContextImpl implements UsAppToPersonContext {
  protected _solution: UsAppToPersonContextSolution;
  protected _uri: string;

  constructor(
    protected _version: V1,
    messagingServiceSid: string,
    sid: string
  ) {
    if (!isValidPathParam(messagingServiceSid)) {
      throw new Error("Parameter 'messagingServiceSid' is not valid.");
    }

    if (!isValidPathParam(sid)) {
      throw new Error("Parameter 'sid' is not valid.");
    }

    this._solution = { messagingServiceSid, sid };
    this._uri = `/Services/${messagingServiceSid}/Compliance/Usa2p/${sid}`;
  }

  remove(
    callback?: (error: Error | null, item?: boolean) => any
  ): Promise<boolean> {
    const instance = this;
    let operationVersion = instance._version,
      operationPromise = operationVersion.remove({
        uri: instance._uri,
        method: "delete",
      });

    operationPromise = instance._version.setPromiseCallback(
      operationPromise,
      callback
    );
    return operationPromise;
  }

  fetch(
    callback?: (error: Error | null, item?: UsAppToPersonInstance) => any
  ): Promise<UsAppToPersonInstance> {
    const instance = this;
    let operationVersion = instance._version,
      operationPromise = operationVersion.fetch({
        uri: instance._uri,
        method: "get",
      });

    operationPromise = operationPromise.then(
      (payload) =>
        new UsAppToPersonInstance(
          operationVersion,
          payload,
          instance._solution.messagingServiceSid,
          instance._solution.sid
        )
    );

    operationPromise = instance._version.setPromiseCallback(
      operationPromise,
      callback
    );
    return operationPromise;
  }

  /**
   * Provide a user-friendly representation
   *
   * @returns Object
   */
  toJSON() {
    return this._solution;
  }

  [inspect.custom](_depth: any, options: InspectOptions) {
    return inspect(this.toJSON(), options);
  }
}

interface UsAppToPersonPayload extends TwilioResponsePayload {
  compliance: UsAppToPersonResource[];
}

interface UsAppToPersonResource {
  sid: string;
  account_sid: string;
  brand_registration_sid: string;
  messaging_service_sid: string;
  description: string;
  message_samples: Array<string>;
  us_app_to_person_usecase: string;
  has_embedded_links: boolean;
  has_embedded_phone: boolean;
  campaign_status: string;
  campaign_id: string;
  is_externally_registered: boolean;
  rate_limits: any;
  message_flow: string;
  opt_in_message: string;
  opt_out_message: string;
  help_message: string;
  opt_in_keywords: Array<string>;
  opt_out_keywords: Array<string>;
  help_keywords: Array<string>;
  date_created: Date;
  date_updated: Date;
  url: string;
  mock: boolean;
}

export class UsAppToPersonInstance {
  protected _solution: UsAppToPersonContextSolution;
  protected _context?: UsAppToPersonContext;

  constructor(
    protected _version: V1,
    payload: UsAppToPersonResource,
    messagingServiceSid: string,
    sid?: string
  ) {
    this.sid = payload.sid;
    this.accountSid = payload.account_sid;
    this.brandRegistrationSid = payload.brand_registration_sid;
    this.messagingServiceSid = payload.messaging_service_sid;
    this.description = payload.description;
    this.messageSamples = payload.message_samples;
    this.usAppToPersonUsecase = payload.us_app_to_person_usecase;
    this.hasEmbeddedLinks = payload.has_embedded_links;
    this.hasEmbeddedPhone = payload.has_embedded_phone;
    this.campaignStatus = payload.campaign_status;
    this.campaignId = payload.campaign_id;
    this.isExternallyRegistered = payload.is_externally_registered;
    this.rateLimits = payload.rate_limits;
    this.messageFlow = payload.message_flow;
    this.optInMessage = payload.opt_in_message;
    this.optOutMessage = payload.opt_out_message;
    this.helpMessage = payload.help_message;
    this.optInKeywords = payload.opt_in_keywords;
    this.optOutKeywords = payload.opt_out_keywords;
    this.helpKeywords = payload.help_keywords;
    this.dateCreated = deserialize.iso8601DateTime(payload.date_created);
    this.dateUpdated = deserialize.iso8601DateTime(payload.date_updated);
    this.url = payload.url;
    this.mock = payload.mock;

    this._solution = { messagingServiceSid, sid: sid || this.sid };
  }

  /**
   * The unique string that identifies a US A2P Compliance resource `QE2c6890da8086d771620e9b13fadeba0b`.
   */
  sid: string;
  /**
   * The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that the Campaign belongs to.
   */
  accountSid: string;
  /**
   * The unique string to identify the A2P brand.
   */
  brandRegistrationSid: string;
  /**
   * The SID of the [Messaging Service](https://www.twilio.com/docs/messaging/services/api) that the resource is associated with.
   */
  messagingServiceSid: string;
  /**
   * A short description of what this SMS campaign does. Min length: 40 characters. Max length: 4096 characters.
   */
  description: string;
  /**
   * Message samples, at least 1 and up to 5 sample messages (at least 2 for starter/sole proprietor), >=20 chars, <=1024 chars each.
   */
  messageSamples: Array<string>;
  /**
   * A2P Campaign Use Case. Examples: [ 2FA, EMERGENCY, MARKETING, STARTER...]. STARTER campaign use cases can only be created by STARTER Brands, and there can only be one STARTER campaign created per STARTER Brand.
   */
  usAppToPersonUsecase: string;
  /**
   * Indicate that this SMS campaign will send messages that contain links.
   */
  hasEmbeddedLinks: boolean;
  /**
   * Indicates that this SMS campaign will send messages that contain phone numbers.
   */
  hasEmbeddedPhone: boolean;
  /**
   * Campaign status. Examples: IN_PROGRESS, VERIFIED, FAILED.
   */
  campaignStatus: string;
  /**
   * The Campaign Registry (TCR) Campaign ID.
   */
  campaignId: string;
  /**
   * Indicates whether the campaign was registered externally or not.
   */
  isExternallyRegistered: boolean;
  /**
   * Rate limit and/or classification set by each carrier, Ex. AT&T or T-Mobile.
   */
  rateLimits: any;
  /**
   * Details around how a consumer opts-in to their campaign, therefore giving consent to receive their messages. If multiple opt-in methods can be used for the same campaign, they must all be listed. 40 character minimum. 2048 character maximum.
   */
  messageFlow: string;
  /**
   * If end users can text in a keyword to start receiving messages from this campaign, the auto-reply messages sent to the end users must be provided. The opt-in response should include the Brand name, confirmation of opt-in enrollment to a recurring message campaign, how to get help, and clear description of how to opt-out. This field is required if end users can text in a keyword to start receiving messages from this campaign. 20 character minimum. 320 character maximum.
   */
  optInMessage: string;
  /**
   * Upon receiving the opt-out keywords from the end users, Twilio customers are expected to send back an auto-generated response, which must provide acknowledgment of the opt-out request and confirmation that no further messages will be sent. It is also recommended that these opt-out messages include the brand name. This field is required if managing opt out keywords yourself (i.e. not using Twilio\'s Default or Advanced Opt Out features). 20 character minimum. 320 character maximum.
   */
  optOutMessage: string;
  /**
   * When customers receive the help keywords from their end users, Twilio customers are expected to send back an auto-generated response; this may include the brand name and additional support contact information. This field is required if managing help keywords yourself (i.e. not using Twilio\'s Default or Advanced Opt Out features). 20 character minimum. 320 character maximum.
   */
  helpMessage: string;
  /**
   * If end users can text in a keyword to start receiving messages from this campaign, those keywords must be provided. This field is required if end users can text in a keyword to start receiving messages from this campaign. Values must be alphanumeric. 255 character maximum.
   */
  optInKeywords: Array<string>;
  /**
   * End users should be able to text in a keyword to stop receiving messages from this campaign. Those keywords must be provided. This field is required if managing opt out keywords yourself (i.e. not using Twilio\'s Default or Advanced Opt Out features). Values must be alphanumeric. 255 character maximum.
   */
  optOutKeywords: Array<string>;
  /**
   * End users should be able to text in a keyword to receive help. Those keywords must be provided as part of the campaign registration request. This field is required if managing help keywords yourself (i.e. not using Twilio\'s Default or Advanced Opt Out features). Values must be alphanumeric. 255 character maximum.
   */
  helpKeywords: Array<string>;
  /**
   * The date and time in GMT when the resource was created specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
   */
  dateCreated: Date;
  /**
   * The date and time in GMT when the resource was last updated specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
   */
  dateUpdated: Date;
  /**
   * The absolute URL of the US App to Person resource.
   */
  url: string;
  /**
   * A boolean that specifies whether campaign is a mock or not. Mock campaigns will be automatically created if using a mock brand. Mock campaigns should only be used for testing purposes.
   */
  mock: boolean;

  private get _proxy(): UsAppToPersonContext {
    this._context =
      this._context ||
      new UsAppToPersonContextImpl(
        this._version,
        this._solution.messagingServiceSid,
        this._solution.sid
      );
    return this._context;
  }

  /**
   * Remove a UsAppToPersonInstance
   *
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed boolean
   */
  remove(
    callback?: (error: Error | null, item?: boolean) => any
  ): Promise<boolean> {
    return this._proxy.remove(callback);
  }

  /**
   * Fetch a UsAppToPersonInstance
   *
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed UsAppToPersonInstance
   */
  fetch(
    callback?: (error: Error | null, item?: UsAppToPersonInstance) => any
  ): Promise<UsAppToPersonInstance> {
    return this._proxy.fetch(callback);
  }

  /**
   * Provide a user-friendly representation
   *
   * @returns Object
   */
  toJSON() {
    return {
      sid: this.sid,
      accountSid: this.accountSid,
      brandRegistrationSid: this.brandRegistrationSid,
      messagingServiceSid: this.messagingServiceSid,
      description: this.description,
      messageSamples: this.messageSamples,
      usAppToPersonUsecase: this.usAppToPersonUsecase,
      hasEmbeddedLinks: this.hasEmbeddedLinks,
      hasEmbeddedPhone: this.hasEmbeddedPhone,
      campaignStatus: this.campaignStatus,
      campaignId: this.campaignId,
      isExternallyRegistered: this.isExternallyRegistered,
      rateLimits: this.rateLimits,
      messageFlow: this.messageFlow,
      optInMessage: this.optInMessage,
      optOutMessage: this.optOutMessage,
      helpMessage: this.helpMessage,
      optInKeywords: this.optInKeywords,
      optOutKeywords: this.optOutKeywords,
      helpKeywords: this.helpKeywords,
      dateCreated: this.dateCreated,
      dateUpdated: this.dateUpdated,
      url: this.url,
      mock: this.mock,
    };
  }

  [inspect.custom](_depth: any, options: InspectOptions) {
    return inspect(this.toJSON(), options);
  }
}

export interface UsAppToPersonSolution {
  messagingServiceSid: string;
}

export interface UsAppToPersonListInstance {
  _version: V1;
  _solution: UsAppToPersonSolution;
  _uri: string;

  (sid: string): UsAppToPersonContext;
  get(sid: string): UsAppToPersonContext;

  /**
   * Create a UsAppToPersonInstance
   *
   * @param params - Parameter for request
   * @param callback - Callback to handle processed record
   *
   * @returns Resolves to processed UsAppToPersonInstance
   */
  create(
    params: UsAppToPersonListInstanceCreateOptions,
    callback?: (error: Error | null, item?: UsAppToPersonInstance) => any
  ): Promise<UsAppToPersonInstance>;

  /**
   * Streams UsAppToPersonInstance records from the API.
   *
   * This operation lazily loads records as efficiently as possible until the limit
   * is reached.
   *
   * The results are passed into the callback function, so this operation is memory
   * efficient.
   *
   * If a function is passed as the first argument, it will be used as the callback
   * function.
   *
   * @param { UsAppToPersonListInstanceEachOptions } [params] - Options for request
   * @param { function } [callback] - Function to process each record
   */
  each(
    callback?: (
      item: UsAppToPersonInstance,
      done: (err?: Error) => void
    ) => void
  ): void;
  each(
    params: UsAppToPersonListInstanceEachOptions,
    callback?: (
      item: UsAppToPersonInstance,
      done: (err?: Error) => void
    ) => void
  ): void;
  /**
   * Retrieve a single target page of UsAppToPersonInstance records from the API.
   *
   * The request is executed immediately.
   *
   * @param { string } [targetUrl] - API-generated URL for the requested results page
   * @param { function } [callback] - Callback to handle list of records
   */
  getPage(
    targetUrl: string,
    callback?: (error: Error | null, items: UsAppToPersonPage) => any
  ): Promise<UsAppToPersonPage>;
  /**
   * Lists UsAppToPersonInstance records from the API as a list.
   *
   * If a function is passed as the first argument, it will be used as the callback
   * function.
   *
   * @param { UsAppToPersonListInstanceOptions } [params] - Options for request
   * @param { function } [callback] - Callback to handle list of records
   */
  list(
    callback?: (error: Error | null, items: UsAppToPersonInstance[]) => any
  ): Promise<UsAppToPersonInstance[]>;
  list(
    params: UsAppToPersonListInstanceOptions,
    callback?: (error: Error | null, items: UsAppToPersonInstance[]) => any
  ): Promise<UsAppToPersonInstance[]>;
  /**
   * Retrieve a single page of UsAppToPersonInstance records from the API.
   *
   * The request is executed immediately.
   *
   * If a function is passed as the first argument, it will be used as the callback
   * function.
   *
   * @param { UsAppToPersonListInstancePageOptions } [params] - Options for request
   * @param { function } [callback] - Callback to handle list of records
   */
  page(
    callback?: (error: Error | null, items: UsAppToPersonPage) => any
  ): Promise<UsAppToPersonPage>;
  page(
    params: UsAppToPersonListInstancePageOptions,
    callback?: (error: Error | null, items: UsAppToPersonPage) => any
  ): Promise<UsAppToPersonPage>;

  /**
   * Provide a user-friendly representation
   */
  toJSON(): any;
  [inspect.custom](_depth: any, options: InspectOptions): any;
}

export function UsAppToPersonListInstance(
  version: V1,
  messagingServiceSid: string
): UsAppToPersonListInstance {
  if (!isValidPathParam(messagingServiceSid)) {
    throw new Error("Parameter 'messagingServiceSid' is not valid.");
  }

  const instance = ((sid) => instance.get(sid)) as UsAppToPersonListInstance;

  instance.get = function get(sid): UsAppToPersonContext {
    return new UsAppToPersonContextImpl(version, messagingServiceSid, sid);
  };

  instance._version = version;
  instance._solution = { messagingServiceSid };
  instance._uri = `/Services/${messagingServiceSid}/Compliance/Usa2p`;

  instance.create = function create(
    params: UsAppToPersonListInstanceCreateOptions,
    callback?: (error: Error | null, items: UsAppToPersonInstance) => any
  ): Promise<UsAppToPersonInstance> {
    if (params === null || params === undefined) {
      throw new Error('Required parameter "params" missing.');
    }

    if (
      params["brandRegistrationSid"] === null ||
      params["brandRegistrationSid"] === undefined
    ) {
      throw new Error(
        "Required parameter \"params['brandRegistrationSid']\" missing."
      );
    }

    if (params["description"] === null || params["description"] === undefined) {
      throw new Error("Required parameter \"params['description']\" missing.");
    }

    if (params["messageFlow"] === null || params["messageFlow"] === undefined) {
      throw new Error("Required parameter \"params['messageFlow']\" missing.");
    }

    if (
      params["messageSamples"] === null ||
      params["messageSamples"] === undefined
    ) {
      throw new Error(
        "Required parameter \"params['messageSamples']\" missing."
      );
    }

    if (
      params["usAppToPersonUsecase"] === null ||
      params["usAppToPersonUsecase"] === undefined
    ) {
      throw new Error(
        "Required parameter \"params['usAppToPersonUsecase']\" missing."
      );
    }

    if (
      params["hasEmbeddedLinks"] === null ||
      params["hasEmbeddedLinks"] === undefined
    ) {
      throw new Error(
        "Required parameter \"params['hasEmbeddedLinks']\" missing."
      );
    }

    if (
      params["hasEmbeddedPhone"] === null ||
      params["hasEmbeddedPhone"] === undefined
    ) {
      throw new Error(
        "Required parameter \"params['hasEmbeddedPhone']\" missing."
      );
    }

    let data: any = {};

    data["BrandRegistrationSid"] = params["brandRegistrationSid"];

    data["Description"] = params["description"];

    data["MessageFlow"] = params["messageFlow"];

    data["MessageSamples"] = serialize.map(
      params["messageSamples"],
      (e: string) => e
    );

    data["UsAppToPersonUsecase"] = params["usAppToPersonUsecase"];

    data["HasEmbeddedLinks"] = serialize.bool(params["hasEmbeddedLinks"]);

    data["HasEmbeddedPhone"] = serialize.bool(params["hasEmbeddedPhone"]);
    if (params["optInMessage"] !== undefined)
      data["OptInMessage"] = params["optInMessage"];
    if (params["optOutMessage"] !== undefined)
      data["OptOutMessage"] = params["optOutMessage"];
    if (params["helpMessage"] !== undefined)
      data["HelpMessage"] = params["helpMessage"];
    if (params["optInKeywords"] !== undefined)
      data["OptInKeywords"] = serialize.map(
        params["optInKeywords"],
        (e: string) => e
      );
    if (params["optOutKeywords"] !== undefined)
      data["OptOutKeywords"] = serialize.map(
        params["optOutKeywords"],
        (e: string) => e
      );
    if (params["helpKeywords"] !== undefined)
      data["HelpKeywords"] = serialize.map(
        params["helpKeywords"],
        (e: string) => e
      );

    const headers: any = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";

    let operationVersion = version,
      operationPromise = operationVersion.create({
        uri: instance._uri,
        method: "post",
        data,
        headers,
      });

    operationPromise = operationPromise.then(
      (payload) =>
        new UsAppToPersonInstance(
          operationVersion,
          payload,
          instance._solution.messagingServiceSid
        )
    );

    operationPromise = instance._version.setPromiseCallback(
      operationPromise,
      callback
    );
    return operationPromise;
  };

  instance.page = function page(
    params?:
      | UsAppToPersonListInstancePageOptions
      | ((error: Error | null, items: UsAppToPersonPage) => any),
    callback?: (error: Error | null, items: UsAppToPersonPage) => any
  ): Promise<UsAppToPersonPage> {
    if (params instanceof Function) {
      callback = params;
      params = {};
    } else {
      params = params || {};
    }

    let data: any = {};

    if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];

    if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
    if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;

    const headers: any = {};

    let operationVersion = version,
      operationPromise = operationVersion.page({
        uri: instance._uri,
        method: "get",
        params: data,
        headers,
      });

    operationPromise = operationPromise.then(
      (payload) =>
        new UsAppToPersonPage(operationVersion, payload, instance._solution)
    );

    operationPromise = instance._version.setPromiseCallback(
      operationPromise,
      callback
    );
    return operationPromise;
  };
  instance.each = instance._version.each;
  instance.list = instance._version.list;

  instance.getPage = function getPage(
    targetUrl: string,
    callback?: (error: Error | null, items: UsAppToPersonPage) => any
  ): Promise<UsAppToPersonPage> {
    const operationPromise = instance._version._domain.twilio.request({
      method: "get",
      uri: targetUrl,
    });

    let pagePromise = operationPromise.then(
      (payload) =>
        new UsAppToPersonPage(instance._version, payload, instance._solution)
    );
    pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
    return pagePromise;
  };

  instance.toJSON = function toJSON() {
    return instance._solution;
  };

  instance[inspect.custom] = function inspectImpl(
    _depth: any,
    options: InspectOptions
  ) {
    return inspect(instance.toJSON(), options);
  };

  return instance;
}

export class UsAppToPersonPage extends Page<
  V1,
  UsAppToPersonPayload,
  UsAppToPersonResource,
  UsAppToPersonInstance
> {
  /**
   * Initialize the UsAppToPersonPage
   *
   * @param version - Version of the resource
   * @param response - Response from the API
   * @param solution - Path solution
   */
  constructor(
    version: V1,
    response: Response<string>,
    solution: UsAppToPersonSolution
  ) {
    super(version, response, solution);
  }

  /**
   * Build an instance of UsAppToPersonInstance
   *
   * @param payload - Payload response from the API
   */
  getInstance(payload: UsAppToPersonResource): UsAppToPersonInstance {
    return new UsAppToPersonInstance(
      this._version,
      payload,
      this._solution.messagingServiceSid
    );
  }

  [inspect.custom](depth: any, options: InspectOptions) {
    return inspect(this.toJSON(), options);
  }
}
